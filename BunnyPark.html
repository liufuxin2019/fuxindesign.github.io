<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<link rel="shortcut icon" type="image/x-icon" href="img/BunnyPark/BunnyParkLogo.png"/>
	<link rel="stylesheet" type="text/css" href="css/normalize.css" />
	<link rel="stylesheet" type="text/css" href="css/component.css" />
</head>
<title>帮你停车 / BunnyPark - 智能共享停车方案</title>
<body>
<div class='container'>
	<section class="section section--menu" id="Prospero">
      <nav class="menu menu--prospero">
        <ul class="menu__list">
          <li class="menu__item"><a class="menu__link" onclick="javascript:setTimeout(function(){location.href='index.html';},150);">首页</a></li>
          <li class="menu__item"><a class="menu__link" onclick="javascript:setTimeout(function(){location.href='gallery.html';},150);">相册</a></li>
          <li class="menu__item"><a class="menu__link" onclick="javascript:setTimeout(function(){location.href='中文简历.pdf';},150);">关于我</a></li>
          <li class="menu__item"><a class="menu__link">English</a></li>
        </ul>
      </nav>
    </section>
<header>
<h1>帮你停车 / BunnyPark</h1>
<p>一款为用户提供智能停车服务的应用设计</p>
</header>
<br>
<h3>基本信息</h3>
产品经理：刘馥欣<br>
用户体验研究员：郝晓蒙、Raphael Helmreich、Alexander Sahm<br>
用户体验设计师：张律平、John Hayden<br>
所属课程：开放设计（同济大学设计创意学院）<br>
指导教师：Hyejin Lee<br>
项目周期：2017.10 - 2017.12<br>
<br/>
<h3>项目背景</h3>
本项目针对上海本地停车位紧缺、商用停车场收费高昂的问题，结合实际应用场景设计了一款名为“帮你停车（BunnyPark）”的App，旨在<b>为用户提供经济便捷的智能停车服务</b>。<br>
团队成员根据实地走访、用户调研、数据收集等方式对上海本地的停车难问题进行了深入了解，并对其形成原因进行了具体分析。调研结果显示，上海本地的停车位使用情况存在明显的“潮汐现象”，即根据所属区域的不同，停车位存在分时紧缺现象。以杨浦区铁岭路彰武路地区为例，在工作日7:30 - 18:00的工作时间段内，在写字楼等上班族聚集的地区存在车位短缺现象，由此引发了许多路边停车的乱象，继而对附近交通造成严重的负面影响，而在居民区附近则存在大量空余车位；在23:00 - 04:00，情况则正好相反。2015年发布的上海第五次综合交通调查报告显示，2014年上海市中心城区夜间停放需求为133万辆，而居住配建的车位仅为64万个，中心城区配建停车位的缺口高达52%，<b>对车位进行资源整合的空间巨大</b><sup><a href="#ref1">[1]</a></sup>。<br>
更多的数据资料显示，这一现象不仅存在于上海，更是存在于国内许多其他大城市。此外，数据显示，北京、上海、广州、深圳等一线城市需求的停车位远远大于实际拥有的停车位，且两者的差距还在逐渐增大。综上所述，团队成员决定制作一款应用，通过为用户提供智能化的停车服务的方式，提高停车位的利用率。<br>
<br/>
<h3>市场调研</h3>
在国内，统计数据显示，停车位缺口率近50%，九成以上的城市车位使用率小于50%，30%的交通拥堵问题是由停车困难造成的，48%的车辆日常须在停车场排队，其中医院附属及周边的停车场排队现象最为严重<sup><a href="#ref2">[2]</a></sup>。研究表明，2018我国传统停车位数量可达到8000万以上，但与之相对的，用户对停车位的需求数量则高达2.8亿，预测2020年这一数字将达到3.7亿。随着供需缺口的不断加大，要想缓解此类矛盾，单凭加大车位供应量很难做到，且因为硬件条件的限制也很难实现，因此，越来越多的人将目光放在了提高停车位利用率这一点上。目前，我国车位使用率相对较低，以上海为例，上海市现有车位的使用率仅为40%，而如果可以利用智慧停车的方式将这一数据提升至80%，那么即使没有新建的停车场，也可以用城市现有的车位满足日益增大的停车需求。<br>
我国的智慧停车市场尚是一个新兴行业，虽然一些团队已经推出了具备车位实时信息共享、车位预定B2C、车位共享P2P和全流程优化功能的应用程序，但多数还是套用了国外的解决方案，未能做到根据本地使用情景进行设计，使得用户保有率不高，成效并不显著。智慧停车是一个很有发展潜力的行业，它可以通过提供实时车场信息、车位引导和电子支付等服务有效减少用户在停车、取车上花费的时间。对使用者来说，智慧停车可以<b>提高用户的出行效率</b>；对城市交通来说，发展智慧停车行业可以<b>实现车位资源的合理分配</b>；对停车场所有方来说，能够通过智慧停车<b>提高自身的营收额</b>，可谓一个三赢的解决方案。
<br/>
<h3>问题分析</h3>
现有的车位共享应用主要依靠建立共享平台的，为车位拥有者及需求者提供对接服务的商业模式运营，但却存在过度依赖弹性社交，对守时性、突发状况估计不足，容易导致<b>客户体验不佳</b>。同时，一些老旧小区在建设时没有完善的停车规划，小区内车位归属方多为开发商、依法取得授权处理的物业管理单位、中介企业或以业主共有的形式存在，因此无法套用车位共享P2P模式，而需采取与小区开发商、物业合作的模式运营。<br>
为了更好的了解上海本地停车的困境，小组成员采访了有日常停车需求的人群，以更好地了解他们的具体需求。
<br/>
<h3>解决方案</h3>
为了解决上述问题，小组成员建立了目标用户群体画像。
<br/>
<h3>用户体验设计</h3>
<br/>
<h3>原型设计</h3>
<br/>
<h3>项目总结</h3>
<br/>
<b>参考资料</b><br>
[1] <a id="ref1" href="#" onclick="window.open('https://wenku.baidu.com/view/6366c931195f312b3069a564.html?re=view')">上海市城乡建设和交通发展研究院. 上海市第五次综合交通调查报告. 2015</a><br>
[2] <a id="ref2" href="#" onclick="window.open('https://cbndata.com/report/505/detail?isReading=report&page=1&readway=across')">智慧停车产业研究院, 第一财经商业数据中心. 2017中国智慧停车行业大数据报告. 2017.12.</a>
</div>


<div class='options'>
<button class='dark'></button>
<button class='light'></button>
</div>
<script id="rendered-js">
function changeColor(e) {
  document.body.className = e.currentTarget.className;
}
[].slice.call(document.querySelectorAll('button'), 0).forEach(function (button) {
  button.addEventListener('click', changeColor);
});
    </script>

<!--nav-->
<script src="js/classienav.js"></script>
  <script src="js/clipboard.min.js"></script>
  <script>
    (function() {
      [].slice.call(document.querySelectorAll('.menu')).forEach(function(menu) {
        var menuItems = menu.querySelectorAll('.menu__link'),
          setCurrent = function(ev) {
            ev.preventDefault();

            var item = ev.target.parentNode; // li

            // return if already current
            if( classie.has(item, 'menu__item--current') ) {
              return false;
            }
            // remove current
            classie.remove(menu.querySelector('.menu__item--current'), 'menu__item--current');
            // set current
            classie.add(item, 'menu__item--current');
          };

        [].slice.call(menuItems).forEach(function(el) {
          el.addEventListener('click', setCurrent);
        });
      });
    })(window);
  </script>
</body>